local function init_fixed ()
	local M = {}

	local template = {
		["push"] = [[

	// push %s %s
	@%s
	D=%s
	@SP
	A=M
	M=D
	@SP
	M=M+1]],

		["pop"] = [[

	// pop %s %s
	@SP
	M=M-1
	A=M
	D=M
	@%s
	M=D
	]]
	}

	local register = {
		["temp"] = {
			["0"] = "R5",
			["1"] = "R6",
			["2"] = "R7",
			["3"] = "R8",
			["4"] = "R9",
			["5"] = "R10",
			["6"] = "R11",
			["7"] = "R12"
		},

		["pointer"] = {
			["0"] = "THIS",
			["1"] = "THAT"
		},

		["static"] = setmetatable({}, {__index = function (_, arg)
			return string.format("%s.%s", "<>", arg)
		end}),

		["constant"] = setmetatable({}, {__index = function (_, arg)
			return arg
		end})
	}

	M.push = function (name, filename)
		return setmetatable({}, {__index = function (_, arg)
			local rname = register[name][arg]

			if filename then
				rname = rname:gsub("<>", filename)
			end

			return string.format(template["push"], name, arg, rname,
				name == "constant" and "A" or "M")
		end})
	end

	M.pop = function (name, filename)
		return  setmetatable({}, {__index = function (_, arg)
			local rname = register[name][arg]

			if filename then
				rname = rname:gsub("<>", filename)
			end

			return string.format(template["pop"], name, arg, rname)
		end})
	end

	return M
end

local function init_heap ()
	local M = {}

	local template = {
		["push"] = [[

	// push %s %s
	@%s
	D=A
	@%s
	A=D+M
	D=M
	@SP
	A=M
	M=D
	@SP
	M=M+1
	]],

		["pop"] = [[

	// pop %s %s
	@%s
	D=A
	@%s
	D=D+M
	@R13
	M=D
	@SP
	M=M-1
	A=M
	D=M
	@R13
	A=M
	M=D]]
	}

	local register = {
		["local"] = "LCL",
		["argument"] = "ARG",
		["this"] = "THIS",
		["that"] = "THAT"
	}

	M.push = function (name)
		return setmetatable({}, {__index = function (_, arg)
			return string.format(template["push"], name, arg, arg, register[name])
		end})
	end

	M.pop = function (name)
		return setmetatable({}, {__index = function (_, arg)
			return string.format(template["pop"], name, arg, arg, register[name])
		end})
	end

	return M
end




local heap = require "heap"
local arith = require "arith"

function M.init (filename)
	local commands = {
		["push"] = {
			-- Commands for fixed segments
			["constant"] = fixed.push("constant"),
			["static"] = fixed.push("static", filename),
			["pointer"] = fixed.push("pointer"),
			["temp"] = fixed.push("temp"),

			-- Commands for heap segments
			["local"] = heap.push("local"),
			["argument"] = heap.push("argument"),
			["this"] = heap.push("this"),
			["that"] = heap.push("that")
		},
		["pop"] = {
			-- Commands for fixed segments
			["static"] = fixed.pop("static", filename),
			["pointer"] = fixed.pop("pointer"),
			["temp"] = fixed.pop("temp"),

			-- Commands for heap segments
			["local"] = heap.pop("local"),
			["argument"] = heap.pop("argument"),
			["this"] = heap.pop("this"),
			["that"] = heap.pop("that")
		},

		-- Arithmetic and logic commands
		["add"] = arith.commands["add"],
		["and"] = arith.commands["and"],
		["or"] = arith.commands["or"],
		["neg"] = arith.commands["neg"],
		["sub"] = arith.commands["sub"],
		["not"] = arith.commands["not"],
	}

	-- Ensure unique labels in stack comparison-operators
	local count = 0

	-- Comparison commands are deliberately absent from '_commands',
	-- so that they trigger this metatable
	setmetatable(commands, {__index = function (_, cmd)
		local snippet = arith.branch(cmd, count)
		count = count + 1

		return snippet
	end})

	return commands
end

return M
