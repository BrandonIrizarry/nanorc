local M = {}

-- A set of proto-commands from which the real commands are derived.
local proto = {
	["nnn"] = [[
@SP
A=M-1
M=%sM]],

	["bin"] = [[
@SP
M=M-1
A=M
D=M
A=A-1
M=%s]],

	["cmp_0"] = [[
@SP
A=M-1
D=M
M=-1
@%s_%s
D;J%s
@SP
A=M-1
M=0
(%s_%s)]]
}

-- The real arithmetic-logic command-set
local commands = {}

commands["neg"] = string.format(proto["nnn"], "-")
commands["not"] = string.format(proto["nnn"], "!")
commands["add"] = string.format(proto["bin"], "D+M")
commands["and"] = string.format(proto["bin"], "D&M")
commands["or"] = string.format(proto["bin"], "D|M")
commands["sub"] = string.format(proto["bin"], "M-D")


local branch_type = {
	["eq"] = "EQ",
	["gt"] = "GT",
	["lt"] = "LT"
}

M.branch = function (cmd, count)
	local snippet = string.format("%s\n%s", commands["sub"],
		string.format(proto["cmp_0"], cmd, tostring(count), branch_type[cmd],
			cmd, tostring(count)))

	-- workaround to achieve the correct comment for comparison operators
	snippet = snippet:gsub("// sub", string.format("// %s", cmd))

	return snippet
end

-- Now add the comment for each snippet
for cmd in pairs(commands) do
	local comment = string.format("\n// %s\n", cmd)

	commands[cmd] = comment .. commands[cmd]
end

M.commands = commands

return M
