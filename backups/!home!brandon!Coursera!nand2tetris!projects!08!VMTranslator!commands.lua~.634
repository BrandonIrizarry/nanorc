-- Global constants
local PUSH_CONSTANT = "@%s D=A @SP A=M M=D @SP M=M+1 "
local PUSH_FIXED = "@%s D=M @SP A=M M=D @SP M=M+1 "
local PUSH_VARIABLE = "@%s D=A @%s A=D+M D=M @SP A=M M=D @SP M=M+1 "
local POP_FIXED = "@SP M=M-1 A=M D=M @%s M=D "
local POP_VARIABLE = "@%s D=A @%s D=D+M @R13 M=D @SP M=M-1 A=M D=M @R13 A=M M=D "
local VMCOMMAND_PATTERN = "[:%.$_%w]+"

-- Use global variables, to avoid naming conflicts with local variables (e.g. function arguments)
_G.filename = ""
_G.fn_name = ""
_G.index = 0

-- Factor out some repeated computations (DRY)
local mt_static_segment = {
	__index = function (cargo, arg)
		local register = "~L".."."..arg
		return string.format(cargo.snippet, register)
	end
}

local mt_pointer_segment = {
	__index = function (cargo, arg)
		local register = (arg == "0" and "THIS") or (arg == "1" and "THAT")
		return string.format(cargo.snippet, register)
	end
}

local mt_temp_segment = {
	__index = function (cargo, arg)
		local register = "R"..tostring(tonumber(arg))
		return string.format(cargo.snippet, register)
	end
}

local mt_variable_segment = {
	__index = function (cargo, arg)
		return string.format(cargo.snippet, arg, cargo.register)
	end
}


local commands = {
	push = {
		-- constant segment
		constant = setmetatable({}, {__index = function (_, arg)
			return string.format(PUSH_CONSTANT, arg)
		end}),

		-- fixed segments (static, pointer, temp)
		static = setmetatable({snippet=PUSH_FIXED}, mt_static_segment),
		pointer = setmetatable({snippet=PUSH_FIXED}, mt_pointer_segment),
		temp = setmetatable({snippet=PUSH_FIXED}, mt_temp_segment),

		-- variable segments (local, argument, this, that)
		["local"]
			= setmetatable({snippet=PUSH_VARIABLE, register="LCL"}, mt_variable_segment),
		argument
			= setmetatable({snippet=PUSH_VARIABLE, register="ARG"}, mt_variable_segment),
		this
			= setmetatable({snippet=PUSH_VARIABLE, register="THIS"}, mt_variable_segment),
		that
			= setmetatable({snippet=PUSH_VARIABLE, register="THAT"}, mt_variable_segment),
	},

	pop = {
		-- fixed segments (static, pointer, temp)
		static = setmetatable({snippet=POP_FIXED}, mt_static_segment),
		pointer = setmetatable({snippet=POP_FIXED}, mt_pointer_segment),
		temp = setmetatable({snippet=POP_FIXED}, mt_temp_segment),

		-- variable segments (local, argument, this, that)
		["local"]
			= setmetatable({snippet=POP_VARIABLE, register="LCL"}, mt_variable_segment),
		argument
			= setmetatable({snippet=POP_VARIABLE, register="ARG"}, mt_variable_segment),
		this
			= setmetatable({snippet=POP_VARIABLE, register="THIS"}, mt_variable_segment),
		that
			= setmetatable({snippet=POP_VARIABLE, register="THAT"}, mt_variable_segment),
	},

	-- Arithmetic and logic commands
	add = "@SP M=M-1 A=M D=M A=A-1 M=D+M ",
	["and"] = "@SP M=M-1 A=M D=M A=A-1 M=D&M ",
	["or"] = "@SP M=M-1 A=M D=M A=A-1 M=D|M ",
	neg = "@SP A=M-1 M=-M ",
	sub = "@SP M=M-1 A=M D=M A=A-1 M=M-D ",
	["not"] = "@SP A=M-1 M=!M ",

	-- 'Incomplete' commands
	["eq"] = "@SP M=M-1 A=M D=M A=A-1 M=M-D ".. -- code for 'sub'
		"@SP A=M-1 D=M M=-1 @~F$eq.~I D;JEQ @SP A=M-1 M=0 (~F$eq.~I) ",

	["lt"] = "@SP M=M-1 A=M D=M A=A-1 M=M-D ".. -- code for 'sub'
		"@SP A=M-1 D=M M=-1 @~F$lt.~I D;JLT @SP A=M-1 M=0 (~F$lt.~I) ",

	["gt"] = "@SP M=M-1 A=M D=M A=A-1 M=M-D ".. -- code for 'sub'
		"@SP A=M-1 D=M M=-1 @~F$gt.~I D;JGT @SP A=M-1 M=0 (~F$gt.~I) "
}

local function metadata ()
	local function emit (line)
		line = line:gsub("//.*", "")

		-- If line is empty, or all whitespace, skip
		if line:match("^%s*$") then
			return false
		end

		local result = commands

		local asm_comment = "// "
		for token in line:gmatch(VMCOMMAND_PATTERN) do
			result = result[token]
			asm_comment = asm_comment..token.." "
		end

		-- Now resolve the tilde-references
		result = result:gsub("~F", _G.fn_name)
		result = result:gsub("~L", _G.filename)
		result = result:gsub("~I", tostring(_G.index))

		-- Properly format the snippet
		result = result:gsub(" ", "\n")

		-- Add the comment and return the final result
		return string.format("\n%s\n%s", asm_comment, result)
	end

	local function emit_from_file (filepath)
		local basename = filepath:gsub(".*/", "")
		local filename = basename:match("[^.]+")
		_G.filename = filename

		local file = assert(io.open(filepath))
		local buffer = {}

		for line in file:lines() do
			local result  = emit(line)
			if result then buffer[#buffer + 1] = result end
		end

		return table.concat(buffer, "")
	end

	return {
		emit_from_file = emit_from_file
	}
end


print(metadata().emit_from_file(arg[1]))

--[==[
local metadata = {
	[fn_name] = "",
	[filename] = "",
	[index] = 0,

	[emit] = function (self, line)
		line = line:gsub("//.*", "")

		-- If line is empty, or all whitespace, skip
		if line:match("^%s*$") then
			return false
		end

		local result = self

		local asm_comment = "// "
		for token in line:gmatch(VMCOMMAND_PATTERN) do
			result = result[token]
			asm_comment = asm_comment..token.." "
		end

		-- Now resolve the tilde-references
		result = result:gsub("~F", self[fn_name])
		result = result:gsub("~L", self[get_filename](self))
		result = result:gsub("~I", self[index])

		-- Properly format the snippet
		result = result:gsub(" ", "\n")

		-- Add the comment and return the final result
		return string.format("\n%s\n%s", asm_comment, result)
	end,

	[emit_from_file] = function (self, filepath)
		local basename = filepath:gsub(".*/", "")
		local filename = basename:match("[^.]+")
		self[filename] = filename -- important

		local file = assert(io.open(filepath))
		local buffer = {}

		for line in file:lines() do
			local result  = self[emit](self, line)
			if result then buffer[#buffer + 1] = result end
		end

		return table.concat(buffer, "")
	end,
}

setmetatable(metadata, {__index = function (metadata, cmd)

	-- Factor out some repeated computations (DRY)
	local mt_static_segment = {
		__index = function (cargo, arg)
			local register = "~L".."."..arg
			return string.format(cargo.snippet, register)
		end
	}

	local mt_pointer_segment = {
		__index = function (cargo, arg)
			local register = (arg == "0" and "THIS") or (arg == "1" and "THAT")
			return string.format(cargo.snippet, register)
		end
	}

	local mt_temp_segment = {
		__index = function (cargo, arg)
			local register = "R"..tostring(tonumber(arg))
			return string.format(cargo.snippet, register)
		end
	}

	local mt_variable_segment = {
		__index = function (cargo, arg)
			return string.format(cargo.snippet, arg, cargo.register)
		end
	}

	local commands = {
		push = {
			-- constant segment
			constant = setmetatable({}, {__index = function (_, arg)
				return string.format(PUSH_CONSTANT, arg)
			end}),

			-- fixed segments (static, pointer, temp)
			static = setmetatable({snippet=PUSH_FIXED}, mt_static_segment),
			pointer = setmetatable({snippet=PUSH_FIXED}, mt_pointer_segment),
			temp = setmetatable({snippet=PUSH_FIXED}, mt_temp_segment),

			-- variable segments (local, argument, this, that)
			["local"]
				= setmetatable({snippet=PUSH_VARIABLE, register="LCL"}, mt_variable_segment),
			argument
				= setmetatable({snippet=PUSH_VARIABLE, register="ARG"}, mt_variable_segment),
			this
				= setmetatable({snippet=PUSH_VARIABLE, register="THIS"}, mt_variable_segment),
			that
				= setmetatable({snippet=PUSH_VARIABLE, register="THAT"}, mt_variable_segment),
		},

		pop = {
			-- fixed segments (static, pointer, temp)
			static = setmetatable({snippet=POP_FIXED}, mt_static_segment),
			pointer = setmetatable({snippet=POP_FIXED}, mt_pointer_segment),
			temp = setmetatable({snippet=POP_FIXED}, mt_temp_segment),

			-- variable segments (local, argument, this, that)
			["local"]
				= setmetatable({snippet=POP_VARIABLE, register="LCL"}, mt_variable_segment),
			argument
				= setmetatable({snippet=POP_VARIABLE, register="ARG"}, mt_variable_segment),
			this
				= setmetatable({snippet=POP_VARIABLE, register="THIS"}, mt_variable_segment),
			that
				= setmetatable({snippet=POP_VARIABLE, register="THAT"}, mt_variable_segment),
		},

		-- Arithmetic and logic commands
		add = "@SP M=M-1 A=M D=M A=A-1 M=D+M ",
		["and"] = "@SP M=M-1 A=M D=M A=A-1 M=D&M ",
		["or"] = "@SP M=M-1 A=M D=M A=A-1 M=D|M ",
		neg = "@SP A=M-1 M=-M ",
		sub = "@SP M=M-1 A=M D=M A=A-1 M=M-D ",
		["not"] = "@SP A=M-1 M=!M ",

		-- 'Incomplete' commands
		["eq"] = "@SP M=M-1 A=M D=M A=A-1 M=M-D ".. -- code for 'sub'
			"@SP A=M-1 D=M M=-1 @~F$eq.~I D;JEQ @SP A=M-1 M=0 (~F$eq.~I) ",

		["lt"] = "@SP M=M-1 A=M D=M A=A-1 M=M-D ".. -- code for 'sub'
			"@SP A=M-1 D=M M=-1 @~F$lt.~I D;JLT @SP A=M-1 M=0 (~F$lt.~I) ",

		["gt"] = "@SP M=M-1 A=M D=M A=A-1 M=M-D ".. -- code for 'sub'
			"@SP A=M-1 D=M M=-1 @~F$gt.~I D;JGT @SP A=M-1 M=0 (~F$gt.~I) "

	}

	-- this function updates 'metadata', but 'emit' will use 'metadata'
	-- as 'self'
	return commands[cmd]
end})

--[=[
	-- next ones: goto, label, and if-goto
	["label"] = setmetatable({}, {__index = function (_, arg)
		return string.format("(~F$%s)", arg)
	end}),

	["goto"] = setmetatable({}, {__index = function (_, arg)
		return string.format("@~F$%s 0;JMP", arg)
	end}),

	["if-goto"] = setmetatable({}, {__index = function (_, arg)
		return string.format("@SP M=M-1 A=M D=M @~F$%s D;JNE", arg)
	end}),

	["function"] = setmetatable({}, {__index = function (_, arg)
		local keys = {["~F"] = arg}
		return setmetatable(keys, {__index = 

}
--]=]
return {
	metadata = metadata,
	emit_from_file = function (filepath)
		return metadata[emit_from_file](metadata, filepath)
	end
}
--]==]
