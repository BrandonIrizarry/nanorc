local M = {}

local nonfixed = require "nonfixed"
local arith = require "arith"
local branching = require "branching"

-- Preamble to avoid code duplication
-- Otherwise, I'd have to inline the same snippets repeatedly, or at least inline
-- the same computations associated with the same segments repeatedly.
local function Fixed (str)
	local function fmt_constant (arg)
		return str:format(arg)
	end

	local function fmt_static (arg)
		return str:format(filename.."."..arg)
	end

	local function fmt_pointer (arg)
		return str:format((arg == "0" and "THIS") or (arg = "1" and "THAT"))
	end

	local function fmt_temp (arg)
		return str:format("R"..tostring(tonumber(arg) + 5))
	end

	return {
		fmt_constant = fmt_constant,
		fmt_static = fmt_static,
		fmt_pointer = fmt_pointer,
		fmt_temp = fmt_temp
	}
end

local function Var (str)
	local function fmt_var (arg, pointer)
		return str:format(arg, pointer)
	end

	return {
		fmt_var = fmt_var
	}
end


-- snippets are displayed in source as being separated by ' ', not '\n'
local snippets = {
	CONST_PUSH = Fixed "@%s D=A @SP A=M M=D @SP M=M+1 ",
	FIXED_PUSH = Fixed "@%s D=M @SP A=M M=D @SP M=M+1 ",
	FIXED_POP = Fixed "@SP M=M-1 A=M D=M @%s M=D ",
	VAR_PUSH = Var "@%s D=A @%s A=D+M D=M @SP A=M M=D @SP M=M+1 ",
	VAR_POP = Var "@%s D=A @%s D=D+M @R13 M=D @SP M=M-1 A=M D=M @R13 A=M M=D "
}

-- end preamble

local metadata = {
	fn_name = "",

	["eq"] = {
		count = 0
	},

	["lt"] = {
		count = 0
	},

	["gt"] = {
		count = 0
	},

	["function"] = {
		count = 0
	},

	["call"] = {
		count = 0
	}
}

local function init (filename)

	local commands = {
		-- Derive code for pushing onto the stack from various memory segments
		["push"] = {
			["constant"] = setmetatable({}, {__index = function (_, arg)
				return snippets.CONST_PUSH.fmt_constant(arg)
			end}),

			["static"] = setmetatable({}, {__index = function (_, arg)
				return snippets.FIXED_PUSH.fmt_static(arg)
			end}),

			["pointer"] = setmetatable({}, {__index = function (_, arg)
				return snippets.FIXED_PUSH.fmt_pointer(arg)
			end}),

			["temp"] = setmetatable({}, {__index = function (_, arg)
				return snippets.FIXED_PUSH.fmt_temp(arg)
			end}),

			["local"] = setmetatable({}, {__index = function (_, arg)
				return snippets.VAR_PUSH.fmt_var(arg, "LCL")
			end}),

			["argument"] = setmetatable({}. {__index = function (_, arg)
				return snippets.VAR_PUSH.fmt_var(arg, "ARG")
			end}),

			["this"] = setmetatable({}. {__index = function (_, arg)
				return snippets.VAR_PUSH.fmt_var(arg, "THIS")
			end}),

			["that"] = setmetatable({}. {__index = function (_, arg)
				return snippets.VAR_PUSH.fmt_var(arg, "THAT")
			end}),
		},

		-- Derive code for popping from the stack onto various memory segments
		["pop"] = {
			["static"] = setmetatable({}, {__index = function (_, arg)
				return snippets.FIXED_POP.fmt_static(arg)
			end}),

			["pointer"] = setmetatable({}, {__index = function (_, arg)
				return snippets.FIXED_POP.fmt_pointer(arg)
			end}),

			["temp"] = setmetatable({}, {__index = function (_, arg)
				return snippets.FIXED_POP.fmt_temp(arg)
			end}),

			["local"] = setmetatable({}, {__index = function (_, arg)
				return snippets.VAR_POP.fmt_var(arg, "LCL")
			end}),

			["argument"] = setmetatable({}, {__index = function (_, arg)
				return snippets.VAR_POP.fmt_var(arg, "ARG")
			end}),

			["this"] = setmetatable({}, {__index = function (_, arg)
				return snippets.VAR_POP.fmt_var(arg, "THIS")
			end}),

			["that"] = setmetatable({}, {__index = function (_, arg)
				return snippets.VAR_POP.fmt_var(arg, "THAT")
			end}),
		},

		-- Arithmetic and logic commands
		["add"] = "@SP M=M-1 A=M D=M A=A-1 M=D+M ",
		["and"] = "@SP M=M-1 A=M D=M A=A-1 M=D&M ",
		["or"] = "@SP M=M-1 A=M D=M A=A-1 M=D|M ",
		["neg"] = "@SP A=M-1 M=-M ",
		["sub"] = "@SP M=M-1 A=M D=M A=A-1 M=M-D ",
		["not"] = "@SP A=M-1 M=!M ",

		["eq"] = setmetatable(metadata, {__index = function (m)
			local count = metadata["eq"].count

			local label_symbol = string.format("%s$cmp.%s",
				metadata.fn_name, tostring(count))

			local result = string.format(
				"@SP A=M-1 D=M M=-1 @%s D;J%s @SP A=M-1 M=0 (%s) ",
				label_symbol, "EQ", label_symbol)

			metadata["eq"].count = count + 1
			return result
		end}),

		["gt"] = setmetatable(metadata, {__index = function (m)
			local count = metadata["gt"].count

			local label_symbol = string.format("%s$cmp.%s",
				metadata.fn_name, tostring(count))

			local result = string.format(
				"@SP A=M-1 D=M M=-1 @%s D;J%s @SP A=M-1 M=0 (%s) ",
				label_symbol, "GT", label_symbol)

			metadata["gt"].count = count + 1
			return result
		end}),

		["lt"] = setmetatable(metadata, {__index = function (m)
			local count = metadata["lt"].count

			local label_symbol = string.format("%s$cmp.%s",
				metadata.fn_name, tostring(count))

			local result = string.format(
				"@SP A=M-1 D=M M=-1 @%s D;J%s @SP A=M-1 M=0 (%s) ",
				label_symbol, "LT", label_symbol)

			metadata["lt"].count = count + 1
			return result
		end}),



		-- Branching commands
		--[[
		["label"] = branching.label(fn_name),
		["goto"] = branching["goto"](fn_name),
		["if-goto"] = branching["if-goto"](fn_name),

		-- Function-call commands except 'call'
		["function"] = setmetatable({}, {__index = function (_, fn_name)
			return setmetatable({}, {__index = function (_, nlocals)

			end})
		end})

		["return"] = setmetatable({}, {__index = function (fn_name)
			return fcall["return"](fn_name, nargs)
		]]
	}

	return commands
end


