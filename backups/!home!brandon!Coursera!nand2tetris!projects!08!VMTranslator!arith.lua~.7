local M = {}

local function emit_negation (symbol)
		return string.format([[
@SP
A=M-1
M=%sM]], symbol)
end

local function emit_binary (term)
	return string.format([[
@SP
M=M-1
A=M
D=M
A=A-1
M=%s]], term)
end

local function emit_comparison (cmd, fn_name, index)
	return string.format([[
@SP
A=M-1
D=M
M=-1
@%s$cmp.%s
D;J%s
@SP
A=M-1
M=0
(%s$cmp.%s)]], fn_name, index, cmd, fn_name, index)
}

-- The real arithmetic-logic command-set
local full_code = {}

full_code["neg"] = emit_negation("-")
full_code["not"] = emit_negation("!")
full_code["add"] = emit_binary("D+M")
full_code["and"] = emit_binary("D&M")
full_code["or"] = emit_binary("D|M")
full_code["sub"] = emit_binary("M-D")

local branch_type = {
	["eq"] = "EQ",
	["gt"] = "GT",
	["lt"] = "LT"
}

M.cmp = {
	["eq"] = function (fn_name, index

--[[
M.branch = function (cmd, count)
	local snippet = string.format("%s\n%s", commands["sub"],
		string.format(proto["cmp_0"], cmd, tostring(count), branch_type[cmd],
			cmd, tostring(count)))

	-- workaround to achieve the correct comment for comparison operators
	snippet = snippet:gsub("// sub", string.format("// %s", cmd))

	return snippet
end

-- Now add the comment for each snippet
for cmd in pairs(commands) do
	local comment = string.format("\n// %s\n", cmd)

	commands[cmd] = comment .. commands[cmd]
end

M.commands = commands

return M
]]
