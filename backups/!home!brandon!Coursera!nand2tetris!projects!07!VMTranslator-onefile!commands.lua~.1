local fixed = {}

local template = {
	["push"] = [[

// push %s %s
@%s
D=%s
@SP
A=M
M=D
@SP
M=M+1]],

	["pop"] = [[

// pop %s %s
@SP
M=M-1
A=M
D=M
@%s
M=D
]]
}

local register = {
	["temp"] = {
		["0"] = "R5",
		["1"] = "R6",
		["2"] = "R7",
		["3"] = "R8",
		["4"] = "R9",
		["5"] = "R10",
		["6"] = "R11",
		["7"] = "R12"
	},

	["pointer"] = {
		["0"] = "THIS",
		["1"] = "THAT"
	},

	["static"] = setmetatable({}, {__index = function (_, arg)
		return string.format("%s.%s", "<>", arg)
	end}),

	["constant"] = setmetatable({}, {__index = function (_, arg)
		return arg
	end})
}

fixed.push = function (name, filename)
	return setmetatable({}, {__index = function (_, arg)
		local rname = register[name][arg]

		if filename then
			rname = rname:gsub("<>", filename)
		end

		return string.format(template["push"], name, arg, rname,
			name == "constant" and "A" or "M")
	end})
end

fixed.pop = function (name, filename)
	return  setmetatable({}, {__index = function (_, arg)
		local rname = register[name][arg]

		if filename then
			rname = rname:gsub("<>", filename)
		end

		return string.format(template["pop"], name, arg, rname)
	end})
end





local heap = require "heap"
local arith = require "arith"

function M.init (filename)
	local commands = {
		["push"] = {
			-- Commands for fixed segments
			["constant"] = fixed.push("constant"),
			["static"] = fixed.push("static", filename),
			["pointer"] = fixed.push("pointer"),
			["temp"] = fixed.push("temp"),

			-- Commands for heap segments
			["local"] = heap.push("local"),
			["argument"] = heap.push("argument"),
			["this"] = heap.push("this"),
			["that"] = heap.push("that")
		},
		["pop"] = {
			-- Commands for fixed segments
			["static"] = fixed.pop("static", filename),
			["pointer"] = fixed.pop("pointer"),
			["temp"] = fixed.pop("temp"),

			-- Commands for heap segments
			["local"] = heap.pop("local"),
			["argument"] = heap.pop("argument"),
			["this"] = heap.pop("this"),
			["that"] = heap.pop("that")
		},

		-- Arithmetic and logic commands
		["add"] = arith.commands["add"],
		["and"] = arith.commands["and"],
		["or"] = arith.commands["or"],
		["neg"] = arith.commands["neg"],
		["sub"] = arith.commands["sub"],
		["not"] = arith.commands["not"],
	}

	-- Ensure unique labels in stack comparison-operators
	local count = 0

	-- Comparison commands are deliberately absent from '_commands',
	-- so that they trigger this metatable
	setmetatable(commands, {__index = function (_, cmd)
		local snippet = arith.branch(cmd, count)
		count = count + 1

		return snippet
	end})

	return commands
end

return M
