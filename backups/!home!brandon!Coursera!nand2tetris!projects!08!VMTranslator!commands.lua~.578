local M = {}

-- Global constants
local PUSH_CONSTANT = "@%s D=A @SP A=M M=D @SP M=M+1 "
local PUSH_FIXED = "@%s D=M @SP A=M M=D @SP M=M+1 "
local PUSH_VARIABLE = "@%s D=A @%s A=D+M D=M @SP A=M M=D @SP M=M+1 "
local POP_FIXED = "@SP M=M-1 A=M D=M @%s M=D "
local POP_VARIABLE = "@%s D=A @%s D=D+M @R13 M=D @SP M=M-1 A=M D=M @R13 A=M M=D "
local VMCOMMAND_PATTERN = "[:%.$_%w]+"

-- Unique keys to avoid clashes with valid VM tokens (e.g. label names, 'push', 'argument', etc.)
local fn_name = {}
local filename = {}
local index = {}
local emit = {}
local emit_from_file = {}
local emit_from_directory = {}

-- Generate snippet based on VM command, but snippets need metadata such as current function,
-- current running index, etc. to be generated properly
local metadata = {
	[fn_name] = "",
	[filename] = "",
	[index] = 0,
	[emit] = function (self, line)
		line = line:gsub("//.*", "")

		-- If line is empty, or all whitespace, skip
		if line:match("^%s*$") then
			return false
		end

		local result = self

		local asm_comment = "// "
		for token in line:gmatch(VMCOMMAND_PATTERN) do
			result = result[token]
			asm_comment = asm_comment..token.." "
		end

		-- Now resolve the tilde-references
		result = result:gsub("~F", self[fn_name])
		result = result:gsub("~L", self[filename])
		result = result:gsub("~I", self[index])

		-- Properly format the snippet
		result = result:gsub(" ", "\n")

		-- Add the comment and return the final result
		return string.format("\n%s\n%s", asm_comment, result)
	end,

	[emit_from_file] = function (self, filepath)
		local basename = filepath:gsub(".*/", "")
		local filename = basename:match("[^.]+")
		self[filename] = filename -- important

		local file = assert(io.open(filepath))
		local buffer = {}

		for line in file:lines() do
			local result  = self[emit](self, line)
			if result then buffer[#buffer + 1] = result end
		end

		return table.concat(buffer, "")
	end,
}

setmetatable(metadata, {__index = function (metadata, cmd)

	-- Factor out some repeated computations (DRY)
	local mt_static_segment = {
		__index = function (cargo, arg)
			local register = "~L".."."..arg
			return string.format(cargo.snippet, register)
		end
	}

	local mt_pointer_segment = {
		__index = function (cargo, arg)
			local register = (arg == "0" and "THIS") or (arg == "1" and "THAT")
			return string.format(cargo.snippet, register)
		end
	}

	local mt_temp_segment = {
		__index = function (cargo, arg)
			local register = "R"..tostring(tonumber(arg))
			return string.format(cargo.snippet, register)
		end
	}

	local mt_variable_segment = {
		__index = function (cargo, arg)
			return string.format(cargo.snippet, arg, cargo.register)
		end
	}

	local commands = {
		push = {
			-- constant segment
			constant = setmetatable({}, {__index = function (_, arg)
				return string.format(PUSH_CONSTANT, arg)
			end}),

			-- fixed segments (static, pointer, temp)
			static = setmetatable({snippet=PUSH_FIXED}, mt_static_segment),
			pointer = setmetatable({snippet=PUSH_FIXED}, mt_pointer_segment),
			temp = setmetatable({snippet=PUSH_FIXED}, mt_temp_segment),

			-- variable segments (local, argument, this, that)
			["local"]
				= setmetatable({snippet=PUSH_VARIABLE, register="LCL"}, mt_variable_segment),
			argument
				= setmetatable({snippet=PUSH_VARIABLE, register="ARG"}, mt_variable_segment),
			this
				= setmetatable({snippet=PUSH_VARIABLE, register="THIS"}, mt_variable_segment),
			that
				= setmetatable({snippet=PUSH_VARIABLE, register="THAT"}, mt_variable_segment),
		},

		pop = {
			-- fixed segments (static, pointer, temp)
			static = setmetatable({snippet=POP_FIXED}, mt_static_segment),
			pointer = setmetatable({snippet=POP_FIXED}, mt_pointer_segment),
			temp = setmetatable({snippet=POP_FIXED}, mt_temp_segment),

			-- variable segments (local, argument, this, that)
			["local"]
				= setmetatable({snippet=POP_VARIABLE, register="LCL"}, mt_variable_segment),
			argument
				= setmetatable({snippet=POP_VARIABLE, register="ARG"}, mt_variable_segment),
			this
				= setmetatable({snippet=POP_VARIABLE, register="THIS"}, mt_variable_segment),
			that
				= setmetatable({snippet=POP_VARIABLE, register="THAT"}, mt_variable_segment),
		},

		-- Arithmetic and logic commands
		add = "@SP M=M-1 A=M D=M A=A-1 M=D+M ",
		["and"] = "@SP M=M-1 A=M D=M A=A-1 M=D&M ",
		["or"] = "@SP M=M-1 A=M D=M A=A-1 M=D|M ",
		neg = "@SP A=M-1 M=-M ",
		sub = "@SP M=M-1 A=M D=M A=A-1 M=M-D ",
		["not"] = "@SP A=M-1 M=!M ",

		-- 'Incomplete' commands
		["eq"] = "@SP M=M-1 A=M D=M A=A-1 M=M-D ".. -- code for 'sub'
			"@SP A=M-1 D=M M=-1 @~F$eq.~I D;JEQ @SP A=M-1 M=0 (~F$eq.~I) ",

		["lt"] = "@SP M=M-1 A=M D=M A=A-1 M=M-D ".. -- code for 'sub'
			"@SP A=M-1 D=M M=-1 @~F$lt.~I D;JLT @SP A=M-1 M=0 (~F$lt.~I) ",

		["gt"] = "@SP M=M-1 A=M D=M A=A-1 M=M-D ".. -- code for 'sub'
			"@SP A=M-1 D=M M=-1 @~F$gt.~I D;JGT @SP A=M-1 M=0 (~F$gt.~I) "

	}

	-- this function updates 'metadata', but 'emit' will use 'metadata'
	-- as 'self'
	return commands[cmd]
end})

--[[
metadata[filename] = "coolfile"
print(metadata[emit](metadata, "push static 0"))
print(metadata[emit](metadata, "pop static 0"))
print(metadata[emit](metadata, "push pointer 1"))
metadata[emit_from_file](metadata, arg[1])
]]

--[=[
--[[
local emitter = {__index = function (trail, arg)
	local command = trail[1]
	local segment = trail[2]

	local function get_register (segment)
		if segment == "constant" then
			return arg
		elseif segment == "static" then
			return filename.."."..arg
		elseif segment == "pointer" then
			return (arg == "0" and "THIS") or (arg == "1" and "THAT")
		elseif segment == "temp" then
			return "R"..tostring(tonumber(arg) + 5)
		else
			local symbol = {
				["local"] = "LCL",
				argument = "ARG",
				this = "THIS",
				that = "THAT",
			}

			return symbol[segment]
		end
	end

	if command == "push" then
		if segment == "local" or segment == "argument" or segment == "this"
			or segment == "that" then
			return string.format("@%s D=A @%s A=D+M D=M @SP A=M M=D @SP M=M+1 ",
				arg, get_register(segment))
		elseif segment == "constant" or segment == "static" or segment == "pointer"
			or segment == "temp" then
			return string.format("@%s D=A @SP A=M M=D @SP M=M+1 ",
				get_register(segment))
		end
	elseif command == "pop" then
		if segment == "local" or segment == "argument" or segment == "this"
			or segment == "that" then
			return string.format("@%s D=A @%s D=D+M @R13 M=D @SP M=M-1 A=M D=M @R13 A=M M=D ",
				arg, get_register(segment))
		elseif segment == "static" or segment == "pointer" or segment == "temp" then
			return string.format("@SP M=M-1 A=M D=M @%s M=D ",
				get_register(segment))
		end
end
--]]

local _commands = {
	-- Derive code for pushing onto the stack from various memory segments
	["push"] = {
		["constant"] = setmetatable({}, {__index = function (_, arg)
			return snippets.CONST_PUSH.fmt_constant(arg)
		end}),

		["static"] = setmetatable({}, {__index = function (_, arg)
			return snippets.FIXED_PUSH.fmt_static(arg)
		end}),

		["pointer"] = setmetatable({}, {__index = function (_, arg)
			return snippets.FIXED_PUSH.fmt_pointer(arg)
		end}),

		["temp"] = setmetatable({}, {__index = function (_, arg)
			return snippets.FIXED_PUSH.fmt_temp(arg)
		end}),

		["local"] = setmetatable({}, {__index = function (_, arg)
			return snippets.VAR_PUSH.fmt_var(arg, "LCL")
		end}),

		["argument"] = setmetatable({}, {__index = function (_, arg)
			return snippets.VAR_PUSH.fmt_var(arg, "ARG")
		end}),

		["this"] = setmetatable({}, {__index = function (_, arg)
			return snippets.VAR_PUSH.fmt_var(arg, "THIS")
		end}),

		["that"] = setmetatable({}, {__index = function (_, arg)
			return snippets.VAR_PUSH.fmt_var(arg, "THAT")
		end}),
	},

	-- Derive code for popping from the stack onto various memory segments
	["pop"] = {
		["static"] = setmetatable({}, {__index = function (_, arg)
			return snippets.FIXED_POP.fmt_static(arg)
		end}),

		["pointer"] = setmetatable({}, {__index = function (_, arg)
			return snippets.FIXED_POP.fmt_pointer(arg)
		end}),

		["temp"] = setmetatable({}, {__index = function (_, arg)
			return snippets.FIXED_POP.fmt_temp(arg)
		end}),

		["local"] = setmetatable({}, {__index = function (_, arg)
			return snippets.VAR_POP.fmt_var(arg, "LCL")
		end}),

		["argument"] = setmetatable({}, {__index = function (_, arg)
			return snippets.VAR_POP.fmt_var(arg, "ARG")
		end}),

		["this"] = setmetatable({}, {__index = function (_, arg)
			return snippets.VAR_POP.fmt_var(arg, "THIS")
		end}),

		["that"] = setmetatable({}, {__index = function (_, arg)
			return snippets.VAR_POP.fmt_var(arg, "THAT")
		end}),
	},

	-- Arithmetic and logic commands
	["add"] = "@SP M=M-1 A=M D=M A=A-1 M=D+M ",
	["and"] = "@SP M=M-1 A=M D=M A=A-1 M=D&M ",
	["or"] = "@SP M=M-1 A=M D=M A=A-1 M=D|M ",
	["neg"] = "@SP A=M-1 M=-M ",
	["sub"] = "@SP M=M-1 A=M D=M A=A-1 M=M-D ",
	["not"] = "@SP A=M-1 M=!M ",

	-- 'Incomplete' commands
	["eq"] = "@SP M=M-1 A=M D=M A=A-1 M=M-D ".. -- code for 'sub'
		"@SP A=M-1 D=M M=-1 @~F$eq.~I D;JEQ @SP A=M-1 M=0 (~F$eq.~I) ",

	["lt"] = "@SP M=M-1 A=M D=M A=A-1 M=M-D ".. -- code for 'sub'
		"@SP A=M-1 D=M M=-1 @~F$lt.~I D;JLT @SP A=M-1 M=0 (~F$lt.~I) ",

	["gt"] = "@SP M=M-1 A=M D=M A=A-1 M=M-D ".. -- code for 'sub'
		"@SP A=M-1 D=M M=-1 @~F$gt.~I D;JGT @SP A=M-1 M=0 (~F$gt.~I) ",

	-- next ones: goto, label, and if-goto
	["label"] = setmetatable({}, {__index = function (_, arg)
		return string.format("(~F$%s)", arg)
	end}),

	["goto"] = setmetatable({}, {__index = function (_, arg)
		return string.format("@~F$%s 0;JMP", arg)
	end}),

	["if-goto"] = setmetatable({}, {__index = function (_, arg)
		return string.format("@SP M=M-1 A=M D=M @~F$%s D;JNE", arg)
	end}),

	["function"] = setmetatable({}, {__index = function (_, arg)
		local keys = {["~F"] = arg}
		return setmetatable(keys, {__index = 

}

-- keys
--[[
local filename = {}
local fn_name = {}
local index = {}

local metadata = {
	[filename] = "",
	[fn_name] = "",
	[index] = 0
}


local commands = setmetatable(metadata, {__index = function (m, cmd)
	local partial = _commands[cmd]
]]

--[[ TODO: we may have to accept that 'commands' can return an incomplete 
	command (i.e., one with ~F and/or ~I tokens inside it); then, our actual 
	commands table is an empty table {} whose metatable's __index metamethod 
	looks up an answer in the original commands table (say we now call it 
	'_commands'), and then does the substitution inside the __index 
	function, updates the metadata table accordingly (can that empty table 
	{} hold the metadata?) and return the completed string. 
	(Come to think of it, the proxy commands table (which'll be called 'commands')
	can hold the metadata, since we only set that metatable _once_, and not 
	pretend to give one client table multiple metatables, which is impossible. 
	That would be a neat solution :) Let's see, tomorrow/next time.]]


local metadata = {
	filename = "",
	current_function = "",
	index = 0,
	commands = _commands,

	derive = function (self, line)
		local result = self.commands

		local asm_comment = "// "

		for token in line:gmatch("[:%.$_%w]+") do -- vm-command pattern
			result = result[token]
			asm_comment = asm_comment..token.." "
		end

		return result, asm_comment
	end,
}
print(metadata:derive("push local 3"))
print(metadata:derive("push static 0"))
print(metadata:derive("goto FUNTIME"))



-- client code (testing)
--[[
local function translate(line, c)
	local running = c
	local asm_comment = "// "

	local vm_command_pattern = "[:%.$_%w]+"

	for token in line:gmatch(vm_command_pattern) do
		running = running[token]
		asm_comment = asm_comment..token.." "
	end

	local code = running:gsub(" ", "\n")
	return string.format("%s\n%s", asm_comment, code)
end

local function real_thing ()
	if not arg[1] then
		print("Missing VM file")
		os.exit()
	end

	local filename = arg[1]:gsub(".*/", "") -- eliminate path to file
	local c = init(filename:match("^[^%.]+")) -- keep only before dot

	local file = assert(io.open(arg[1]))

	for line in file:lines() do
		line = line:gsub("//.*", "") -- delete any comments on the line

		-- if line is empty, or all whitespace, skip
		if line:match("^%s*$") then
			goto continue
		end

		print(translate(line, c))
		::continue::
	end
end
]]
--]=]

