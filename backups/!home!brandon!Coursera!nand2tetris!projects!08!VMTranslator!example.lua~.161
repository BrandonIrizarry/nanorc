local lfs = require "lfs"

--[[
for _, test in ipairs(arg) do
	_ENV[test] = test -- to specify testing-function on the command-line
	active_tests[#active_tests + 1] = _ENV[test]
end
]]

setmetatable(_ENV, {
	__index = function (_, nonexistent)
		error(string.format("nonexistent global '%s'", nonexistent), 2)
	end,

	__newindex = function (_, prohibited)
		error(string.format("cannot write to new global '%s'", prohibited), 2)
	end
})

local tests = {
	["BasicLoop.vm"] = {
		prefix = "",
		realname = "BasicLoop",
		extension = "vm"
	},

	["../ProgramFlow/BasicLoop.vm"] = {
		prefix = "../ProgramFlow/",
		realname = "BasicLoop",
		extension = "vm"
	},

	NestedCall = {
		prefix = "",
		realname = "NestedCall",
		extension = ""
	},

	["NestedCall/"] = {
		prefix = "",
		realname = "NestedCall",
		extension = ""
	},

	["../FunctionCalls/NestedCall/"] = {
		prefix = "../FunctionCalls/",
		realname = "NestedCall",
		extension = ""
	},

	["../FunctionCalls/NestedCall"] = {
		prefix = "../FunctionCalls/",
		realname = "NestedCall",
		extension = ""
	}
}

local BASENAME_PATTERN = "(.-/?)([^/]+)/?$"

local function prefix_rest (input)
	local prefix, rest = input:match(BASENAME_PATTERN)
	return prefix, rest
end

-- Assumes you've given it a valid filename, without the path to it
--[[
local function realname_extension (rest)
--	local realname, extension = rest:match("(.*)%.([^.]+$"
	local realname, extension = rest:match("(.*)%.(.*)$")
	return realname, extension
end
]]

local function printf (fmt, ...)
	return io.write(string.format(fmt, ...))
end

-- can take whole cli input
local function get_extension (basename)
	return basename:match("%.([^./]+)$")
end


local function get_prefix (cli_input)
	return cli_input:match(".*/")
end

for _, test in ipairs(arg) do
	test()
end
