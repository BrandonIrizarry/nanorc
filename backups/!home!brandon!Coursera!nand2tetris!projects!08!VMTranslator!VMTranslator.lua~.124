-- Hack-assembly snippet templates
local constants = require "constants"

-- Promote these constants into global scope, for ease of use.
for key in pairs(constants) do
	_G[key] = constants[key]
end

-- Use global variables, to avoid naming conflicts with local variables
-- These will appear throughout the file with their '_G.' prefix.
_G.filename = ""
_G.fn_name = ""
_G.index = 0

-- Factor out some repeated computations (DRY)
-- cargo: a way to identify the segment to be used, and possibly the register (LCL, etc.)
local mt_static_segment = {
	__index = function (cargo, arg)
		local register = _G.filename.."."..arg
		return string.format(cargo.snippet, register)
	end
}

local mt_pointer_segment = {
	__index = function (cargo, arg)
		local register = (arg == "0" and "THIS") or (arg == "1" and "THAT")
		return string.format(cargo.snippet, register)
	end
}

local mt_temp_segment = {
	__index = function (cargo, arg)
		local register = "R"..tostring(tonumber(arg) + 5)
		return string.format(cargo.snippet, register)
	end
}

local mt_variable_segment = {
	__index = function (cargo, arg)
		return string.format(cargo.snippet, arg, cargo.register)
	end
}


local commands = {
	push = {
		-- constant segment
		constant = setmetatable({}, {__index = function (_, arg)
			return string.format(PUSH_CONSTANT, arg)
		end}),

		-- fixed segments (static, pointer, temp)
		static = setmetatable({snippet=PUSH_FIXED}, mt_static_segment),
		pointer = setmetatable({snippet=PUSH_FIXED}, mt_pointer_segment),
		temp = setmetatable({snippet=PUSH_FIXED}, mt_temp_segment),

		-- variable segments (local, argument, this, that)
		["local"] = setmetatable({snippet=PUSH_VARIABLE, register="LCL"},
			mt_variable_segment),
		argument = setmetatable({snippet=PUSH_VARIABLE, register="ARG"},
			mt_variable_segment),
		this = setmetatable({snippet=PUSH_VARIABLE, register="THIS"},
			mt_variable_segment),
		that = setmetatable({snippet=PUSH_VARIABLE, register="THAT"},
			mt_variable_segment),
	},

	pop = {
		-- fixed segments (static, pointer, temp)
		static = setmetatable({snippet=POP_FIXED}, mt_static_segment),
		pointer = setmetatable({snippet=POP_FIXED}, mt_pointer_segment),
		temp = setmetatable({snippet=POP_FIXED}, mt_temp_segment),

		-- variable segments (local, argument, this, that)
		["local"]
			= setmetatable({snippet=POP_VARIABLE, register="LCL"}, mt_variable_segment),
		argument
			= setmetatable({snippet=POP_VARIABLE, register="ARG"}, mt_variable_segment),
		this
			= setmetatable({snippet=POP_VARIABLE, register="THIS"}, mt_variable_segment),
		that
			= setmetatable({snippet=POP_VARIABLE, register="THAT"}, mt_variable_segment),
	},

	-- Arithmetic and logic commands
	add = ADD,
	["and"] = AND,
	["or"] = OR,
	neg = NEG,
	sub = SUB,
	["not"] = NOT,

	["label"] = setmetatable({}, {__index = function (_, arg)
		return string.format(LABEL, _G.fn_name, arg)
	end}),

	["goto"] = setmetatable({}, {__index = function (_, arg)
		return string.format(GOTO, _G.fn_name, arg)
	end}),

	["if-goto"] = setmetatable({}, {__index = function (_, arg)
		return string.format(IF_GOTO, _G.fn_name, arg)
	end}),

	["function"] = setmetatable({}, {__index = function (_, fn_name)
		_G.fn_name = fn_name

		return setmetatable({}, {__index = function (_, nlocals)
			return FUNCTION:format(fn_name, nlocals, fn_name, fn_name,
				 fn_name, fn_name)
		end})
	end}),

	call = setmetatable({}, {__index = function (_, callee_fn)
		return setmetatable({}, {__index = function (_, nargs)
			_G.index = _G.index + 1
			return CALL:format(_G.fn_name, _G.index, nargs, callee_fn, _G.fn_name, _G.index)
		end})
	end}),

	["return"] = RETURN
}

-- Since comparison operators take no arguments, we don't have an excuse to
-- call an __index metamethod to update _G.index; so easiest to do it this way.
setmetatable(commands, {__index = function (_, cmd)
	local comparison_ops = {
		["eq"] = EQ,
		["lt"] = LT,
		["gt"] = GT
	}

	_G.index = _G.index + 1

	return string.format(comparison_ops[cmd], _G.index, _G.index)
end})


local function metadata ()
	local function emit (line)
		line = line:gsub("//.*", "")

		-- If line is empty, or all whitespace, skip
		if line:match("^%s*$") then
			return false
		end

		local result = commands

		local asm_comment = "// "
		for token in line:gmatch(VMCOMMAND_PATTERN) do
			result = result[token]
			asm_comment = asm_comment..token.." "
		end

		-- Add the comment and return the final result
		return string.format("\n%s\n%s", asm_comment, result)
	end

	local function emit_from_file (stream, basename)
		local filename = basename:match("[^.]+")

		_G.filename = filename

		local buffer = {}

		for line in stream:lines() do
			local result  = emit(line)
			if result then buffer[#buffer + 1] = result end
		end

		return table.concat(buffer, "")
	end

	return {
		emit = emit,
		emit_from_file = emit_from_file,
	}
end

local emitter = metadata()

local function to_file (input)
	local basename = input:match(BASENAME_PATTERN)

	local lfs = require "lfs"
	local mode = lfs.attributes(input).mode

	local program = {"SP=256", emitter.emit("call Sys.init")}
	local stream

	if mode == "file" then
		stream = io.open(input)
		program[#program + 1] = emitter.emit_from_file(stream, basename)
		stream:close()
	elseif mode == "directory" then
		for entry in lfs.dir(input) do
			if lfs.attributes(entry).mode == "file" then
				local extension = entry:match("%.([^.]+)$")

				if extension == "vm" then
					stream = io.open(entry)
					program[#program + 1] = emitter.emit_from_file(stream, basename)
					stream:close()
				end
			end
		end
	else
		print("Neither a file nor directory")
		os.exit()
	end
--[[
local function to_file (file_or_dir)
	local lfs = require "lfs"
	local type = lfs.attributes(file_or_dir).mode

	print(type, type=="directory")

	local emit_from_place = (type == "file" and emitter.emit_from_file)
		or (type == "directory" and emitter.emit_from_directory)

	print(_G.type(emit_from_place))

	local code, asm_filename = emit_from_place(file_or_dir)
	asm_filename = asm_filename..".asm"

	local asm_text = {
		"SP=256",
		emitter.emit("call Sys.init"),
		code
	}

	asm_text = table.concat(asm_text, "\n")

	return assert(io.open(asm_filename, "w"):write(asm_text):close())
end

to_file(arg[1])
--]]
